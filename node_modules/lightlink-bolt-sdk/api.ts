/* tslint:disable */
/* eslint-disable */
/**
 * TSOA
 * Build swagger-compliant REST APIs using TypeScript and Node
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export const AccountType = {
    Managed: 'MANAGED',
    ExternallyOwned: 'EXTERNALLY_OWNED'
} as const;

export type AccountType = typeof AccountType[keyof typeof AccountType];


/**
 * 
 * @export
 * @enum {string}
 */

export const ContractExecutionStatus = {
    Pending: 'PENDING',
    Success: 'SUCCESS',
    Failed: 'FAILED'
} as const;

export type ContractExecutionStatus = typeof ContractExecutionStatus[keyof typeof ContractExecutionStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const ContractType = {
    Erc20: 'ERC20',
    Erc721: 'ERC721',
    Erc1155: 'ERC1155',
    Custom: 'CUSTOM'
} as const;

export type ContractType = typeof ContractType[keyof typeof ContractType];


/**
 * 
 * @export
 * @interface GetExecutions200Response
 */
export interface GetExecutions200Response {
    /**
     * 
     * @type {Array<IContractExecution>}
     * @memberof GetExecutions200Response
     */
    'executions': Array<IContractExecution>;
    /**
     * 
     * @type {number}
     * @memberof GetExecutions200Response
     */
    'totalCount': number;
    /**
     * 
     * @type {string}
     * @memberof GetExecutions200Response
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface GetExecutions200ResponseAnyOf
 */
export interface GetExecutions200ResponseAnyOf {
    /**
     * 
     * @type {string}
     * @memberof GetExecutions200ResponseAnyOf
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface IAccount
 */
export interface IAccount {
    /**
     * 
     * @type {boolean}
     * @memberof IAccount
     */
    'removed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IAccount
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof IAccount
     */
    'modified'?: string;
    /**
     * 
     * @type {string}
     * @memberof IAccount
     */
    'key': string;
    /**
     * 
     * @type {AccountType}
     * @memberof IAccount
     */
    'type': AccountType;
    /**
     * 
     * @type {string}
     * @memberof IAccount
     */
    'external_ref': string;
    /**
     * 
     * @type {string}
     * @memberof IAccount
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof IAccount
     */
    'organisation_key': string;
    /**
     * 
     * @type {IEncryption}
     * @memberof IAccount
     */
    'encryption'?: IEncryption;
}


/**
 * 
 * @export
 * @interface IContract
 */
export interface IContract {
    /**
     * 
     * @type {boolean}
     * @memberof IContract
     */
    'removed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IContract
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof IContract
     */
    'modified'?: string;
    /**
     * 
     * @type {string}
     * @memberof IContract
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof IContract
     */
    'address': string;
    /**
     * 
     * @type {IContractMetadata}
     * @memberof IContract
     */
    'metadata': IContractMetadata;
    /**
     * 
     * @type {Array<any>}
     * @memberof IContract
     */
    'abi': Array<any>;
    /**
     * 
     * @type {boolean}
     * @memberof IContract
     */
    'active': boolean;
    /**
     * 
     * @type {ContractType}
     * @memberof IContract
     */
    'type': ContractType;
    /**
     * 
     * @type {string}
     * @memberof IContract
     */
    'organisation_key': string;
}


/**
 * 
 * @export
 * @interface IContractExecution
 */
export interface IContractExecution {
    /**
     * 
     * @type {string}
     * @memberof IContractExecution
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof IContractExecution
     */
    'organisation_key': string;
    /**
     * 
     * @type {string}
     * @memberof IContractExecution
     */
    'contract_address': string;
    /**
     * 
     * @type {string}
     * @memberof IContractExecution
     */
    'function_name': string;
    /**
     * 
     * @type {Array<any>}
     * @memberof IContractExecution
     */
    'args': Array<any>;
    /**
     * 
     * @type {ContractExecutionStatus}
     * @memberof IContractExecution
     */
    'status': ContractExecutionStatus;
    /**
     * 
     * @type {string}
     * @memberof IContractExecution
     */
    'hash'?: string;
    /**
     * 
     * @type {any}
     * @memberof IContractExecution
     */
    'token_metadata'?: any;
    /**
     * 
     * @type {string}
     * @memberof IContractExecution
     */
    'error'?: string;
    /**
     * 
     * @type {any}
     * @memberof IContractExecution
     */
    'receipt'?: any;
}


/**
 * 
 * @export
 * @interface IContractExecutionListResponse
 */
export interface IContractExecutionListResponse {
    /**
     * 
     * @type {Array<IContractExecution>}
     * @memberof IContractExecutionListResponse
     */
    'executions': Array<IContractExecution>;
    /**
     * 
     * @type {number}
     * @memberof IContractExecutionListResponse
     */
    'totalCount': number;
}
/**
 * 
 * @export
 * @interface IContractMetadata
 */
export interface IContractMetadata {
    /**
     * 
     * @type {string}
     * @memberof IContractMetadata
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof IContractMetadata
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof IContractMetadata
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof IContractMetadata
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof IContractMetadata
     */
    'banner_image'?: string;
}
/**
 * 
 * @export
 * @interface IContractsListResponse
 */
export interface IContractsListResponse {
    /**
     * 
     * @type {number}
     * @memberof IContractsListResponse
     */
    'page_size': number;
    /**
     * 
     * @type {number}
     * @memberof IContractsListResponse
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof IContractsListResponse
     */
    'total_items': number;
    /**
     * 
     * @type {Array<IContract>}
     * @memberof IContractsListResponse
     */
    'items': Array<IContract>;
}
/**
 * 
 * @export
 * @interface ICreateAccount
 */
export interface ICreateAccount {
    /**
     * 
     * @type {AccountType}
     * @memberof ICreateAccount
     */
    'type': AccountType;
    /**
     * 
     * @type {string}
     * @memberof ICreateAccount
     */
    'external_ref': string;
}


/**
 * 
 * @export
 * @interface IDeployContract
 */
export interface IDeployContract {
    /**
     * 
     * @type {IContractMetadata}
     * @memberof IDeployContract
     */
    'metadata': IContractMetadata;
    /**
     * 
     * @type {ContractType}
     * @memberof IDeployContract
     */
    'type': ContractType;
}


/**
 * 
 * @export
 * @interface IEncryption
 */
export interface IEncryption {
    /**
     * 
     * @type {string}
     * @memberof IEncryption
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof IEncryption
     */
    'salt': string;
    /**
     * 
     * @type {string}
     * @memberof IEncryption
     */
    'key_store': string;
}
/**
 * 
 * @export
 * @interface IInitiateSessionResponse
 */
export interface IInitiateSessionResponse {
    /**
     * 
     * @type {string}
     * @memberof IInitiateSessionResponse
     */
    'sessionKey': string;
    /**
     * 
     * @type {string}
     * @memberof IInitiateSessionResponse
     */
    'salt': string;
    /**
     * 
     * @type {string}
     * @memberof IInitiateSessionResponse
     */
    'userKey': string;
    /**
     * 
     * @type {string}
     * @memberof IInitiateSessionResponse
     */
    'encryptionKey': string;
}
/**
 * 
 * @export
 * @interface INFTAttribute
 */
export interface INFTAttribute {
    /**
     * 
     * @type {string}
     * @memberof INFTAttribute
     */
    'trait_type': string;
    /**
     * 
     * @type {INFTAttributeValue}
     * @memberof INFTAttribute
     */
    'value': INFTAttributeValue;
}
/**
 * 
 * @export
 * @interface INFTAttributeValue
 */
export interface INFTAttributeValue {
}
/**
 * 
 * @export
 * @interface INFTMetadata
 */
export interface INFTMetadata {
    /**
     * 
     * @type {string}
     * @memberof INFTMetadata
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof INFTMetadata
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof INFTMetadata
     */
    'image'?: string;
    /**
     * 
     * @type {Array<INFTAttribute>}
     * @memberof INFTMetadata
     */
    'attributes': Array<INFTAttribute>;
}
/**
 * 
 * @export
 * @interface IOrganisation
 */
export interface IOrganisation {
    /**
     * 
     * @type {boolean}
     * @memberof IOrganisation
     */
    'removed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IOrganisation
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof IOrganisation
     */
    'modified'?: string;
    /**
     * 
     * @type {string}
     * @memberof IOrganisation
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof IOrganisation
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof IOrganisation
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof IOrganisation
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof IOrganisation
     */
    'banner_image': string;
}
/**
 * 
 * @export
 * @interface IPostAuthInitiate
 */
export interface IPostAuthInitiate {
    /**
     * 
     * @type {string}
     * @memberof IPostAuthInitiate
     */
    'userKey': string;
}
/**
 * 
 * @export
 * @interface IPostContract
 */
export interface IPostContract {
    /**
     * 
     * @type {string}
     * @memberof IPostContract
     */
    'address': string;
    /**
     * 
     * @type {IContractMetadata}
     * @memberof IPostContract
     */
    'metadata': IContractMetadata;
    /**
     * 
     * @type {Array<any>}
     * @memberof IPostContract
     */
    'abi': Array<any>;
}
/**
 * 
 * @export
 * @interface IPostContractExecution
 */
export interface IPostContractExecution {
    /**
     * 
     * @type {string}
     * @memberof IPostContractExecution
     */
    'contract_address': string;
    /**
     * 
     * @type {string}
     * @memberof IPostContractExecution
     */
    'function_name': string;
    /**
     * 
     * @type {Array<any>}
     * @memberof IPostContractExecution
     */
    'args': Array<any>;
}
/**
 * 
 * @export
 * @interface IPostCreateWebhook
 */
export interface IPostCreateWebhook {
    /**
     * 
     * @type {string}
     * @memberof IPostCreateWebhook
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface IPostMintErc155
 */
export interface IPostMintErc155 {
    /**
     * 
     * @type {number}
     * @memberof IPostMintErc155
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof IPostMintErc155
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof IPostMintErc155
     */
    'token_id': string;
}
/**
 * 
 * @export
 * @interface IPostMintErc20
 */
export interface IPostMintErc20 {
    /**
     * 
     * @type {number}
     * @memberof IPostMintErc20
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof IPostMintErc20
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface IPostMintErc721
 */
export interface IPostMintErc721 {
    /**
     * 
     * @type {INFTMetadata}
     * @memberof IPostMintErc721
     */
    'metadata': INFTMetadata;
    /**
     * 
     * @type {number}
     * @memberof IPostMintErc721
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof IPostMintErc721
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface IPostOrganisation
 */
export interface IPostOrganisation {
    /**
     * Name of the organisation
     * @type {string}
     * @memberof IPostOrganisation
     */
    'name': string;
    /**
     * Description of the organisation
     * @type {string}
     * @memberof IPostOrganisation
     */
    'description': string;
    /**
     * URL to the organisation\'s logo
     * @type {string}
     * @memberof IPostOrganisation
     */
    'image': string;
    /**
     * URL to the organisation\'s banner image
     * @type {string}
     * @memberof IPostOrganisation
     */
    'banner_image': string;
}
/**
 * 
 * @export
 * @interface IPostOrganisationResponse
 */
export interface IPostOrganisationResponse {
    /**
     * 
     * @type {boolean}
     * @memberof IPostOrganisationResponse
     */
    'removed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IPostOrganisationResponse
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof IPostOrganisationResponse
     */
    'modified'?: string;
    /**
     * 
     * @type {string}
     * @memberof IPostOrganisationResponse
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof IPostOrganisationResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof IPostOrganisationResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof IPostOrganisationResponse
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof IPostOrganisationResponse
     */
    'banner_image': string;
    /**
     * API key for the organisation
     * @type {string}
     * @memberof IPostOrganisationResponse
     */
    'api_key': string;
}
/**
 * 
 * @export
 * @interface IPostReadContract
 */
export interface IPostReadContract {
    /**
     * 
     * @type {string}
     * @memberof IPostReadContract
     */
    'function_name': string;
    /**
     * 
     * @type {Array<any>}
     * @memberof IPostReadContract
     */
    'args': Array<any>;
}
/**
 * 
 * @export
 * @interface IPostTransferErc1155
 */
export interface IPostTransferErc1155 {
    /**
     * 
     * @type {string}
     * @memberof IPostTransferErc1155
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof IPostTransferErc1155
     */
    'to': string;
    /**
     * 
     * @type {number}
     * @memberof IPostTransferErc1155
     */
    'tokenId': number;
    /**
     * 
     * @type {number}
     * @memberof IPostTransferErc1155
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface IPostTransferErc20
 */
export interface IPostTransferErc20 {
    /**
     * 
     * @type {string}
     * @memberof IPostTransferErc20
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof IPostTransferErc20
     */
    'to': string;
    /**
     * 
     * @type {number}
     * @memberof IPostTransferErc20
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface IPostTransferErc721
 */
export interface IPostTransferErc721 {
    /**
     * 
     * @type {string}
     * @memberof IPostTransferErc721
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof IPostTransferErc721
     */
    'to': string;
    /**
     * 
     * @type {number}
     * @memberof IPostTransferErc721
     */
    'tokenId': number;
}
/**
 * 
 * @export
 * @interface IPostUser
 */
export interface IPostUser {
    /**
     * 
     * @type {string}
     * @memberof IPostUser
     */
    'address': string;
}
/**
 * 
 * @export
 * @interface IPostUserOrganisation
 */
export interface IPostUserOrganisation {
    /**
     * 
     * @type {string}
     * @memberof IPostUserOrganisation
     */
    'user_address': string;
    /**
     * 
     * @type {string}
     * @memberof IPostUserOrganisation
     */
    'organisation_key': string;
    /**
     * 
     * @type {UserOrganisationType}
     * @memberof IPostUserOrganisation
     */
    'type': UserOrganisationType;
}


/**
 * 
 * @export
 * @interface IPutUser
 */
export interface IPutUser {
    /**
     * 
     * @type {string}
     * @memberof IPutUser
     */
    'address': string;
}
/**
 * 
 * @export
 * @interface IPutUserOrganisation
 */
export interface IPutUserOrganisation {
    /**
     * 
     * @type {UserOrganisationType}
     * @memberof IPutUserOrganisation
     */
    'type'?: UserOrganisationType;
    /**
     * 
     * @type {boolean}
     * @memberof IPutUserOrganisation
     */
    'active'?: boolean;
}


/**
 * 
 * @export
 * @interface IReadContractResponse
 */
export interface IReadContractResponse {
    /**
     * 
     * @type {any}
     * @memberof IReadContractResponse
     */
    'result': any;
}
/**
 * 
 * @export
 * @interface ITokenAccount
 */
export interface ITokenAccount {
    /**
     * 
     * @type {boolean}
     * @memberof ITokenAccount
     */
    'removed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ITokenAccount
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof ITokenAccount
     */
    'modified'?: string;
    /**
     * 
     * @type {string}
     * @memberof ITokenAccount
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ITokenAccount
     */
    'contract': string;
    /**
     * 
     * @type {string}
     * @memberof ITokenAccount
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof ITokenAccount
     */
    'organisation_key': string;
    /**
     * 
     * @type {number}
     * @memberof ITokenAccount
     */
    'token_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ITokenAccount
     */
    'balance_raw': string;
    /**
     * 
     * @type {number}
     * @memberof ITokenAccount
     */
    'balance': number;
}
/**
 * 
 * @export
 * @interface ITokenAccountListResponse
 */
export interface ITokenAccountListResponse {
    /**
     * 
     * @type {number}
     * @memberof ITokenAccountListResponse
     */
    'page_size': number;
    /**
     * 
     * @type {number}
     * @memberof ITokenAccountListResponse
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof ITokenAccountListResponse
     */
    'total_items': number;
    /**
     * 
     * @type {Array<ITokenAccount>}
     * @memberof ITokenAccountListResponse
     */
    'items': Array<ITokenAccount>;
}
/**
 * 
 * @export
 * @interface ITokenTransfer
 */
export interface ITokenTransfer {
    /**
     * 
     * @type {boolean}
     * @memberof ITokenTransfer
     */
    'removed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ITokenTransfer
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof ITokenTransfer
     */
    'modified'?: string;
    /**
     * 
     * @type {string}
     * @memberof ITokenTransfer
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ITokenTransfer
     */
    'hash': string;
    /**
     * 
     * @type {string}
     * @memberof ITokenTransfer
     */
    'contract': string;
    /**
     * 
     * @type {string}
     * @memberof ITokenTransfer
     */
    'from_address': string;
    /**
     * 
     * @type {string}
     * @memberof ITokenTransfer
     */
    'to_address': string;
    /**
     * 
     * @type {string}
     * @memberof ITokenTransfer
     */
    'organisation_key': string;
    /**
     * 
     * @type {number}
     * @memberof ITokenTransfer
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof ITokenTransfer
     */
    'token_id'?: number;
}
/**
 * 
 * @export
 * @interface ITokenTransferListResponse
 */
export interface ITokenTransferListResponse {
    /**
     * 
     * @type {number}
     * @memberof ITokenTransferListResponse
     */
    'page_size': number;
    /**
     * 
     * @type {number}
     * @memberof ITokenTransferListResponse
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof ITokenTransferListResponse
     */
    'total_items': number;
    /**
     * 
     * @type {Array<ITokenTransfer>}
     * @memberof ITokenTransferListResponse
     */
    'items': Array<ITokenTransfer>;
}
/**
 * 
 * @export
 * @interface ITransaction
 */
export interface ITransaction {
    /**
     * 
     * @type {boolean}
     * @memberof ITransaction
     */
    'removed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ITransaction
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof ITransaction
     */
    'modified'?: string;
    /**
     * 
     * @type {string}
     * @memberof ITransaction
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ITransaction
     */
    'hash': string;
    /**
     * 
     * @type {string}
     * @memberof ITransaction
     */
    'contract': string;
    /**
     * 
     * @type {string}
     * @memberof ITransaction
     */
    'receipt': string;
    /**
     * 
     * @type {string}
     * @memberof ITransaction
     */
    'organisation_key': string;
}
/**
 * 
 * @export
 * @interface ITransactionListResponse
 */
export interface ITransactionListResponse {
    /**
     * 
     * @type {number}
     * @memberof ITransactionListResponse
     */
    'page_size': number;
    /**
     * 
     * @type {number}
     * @memberof ITransactionListResponse
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof ITransactionListResponse
     */
    'total_items': number;
    /**
     * 
     * @type {Array<ITransaction>}
     * @memberof ITransactionListResponse
     */
    'items': Array<ITransaction>;
}
/**
 * 
 * @export
 * @interface IUser
 */
export interface IUser {
    /**
     * 
     * @type {boolean}
     * @memberof IUser
     */
    'removed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IUser
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof IUser
     */
    'modified'?: string;
    /**
     * 
     * @type {string}
     * @memberof IUser
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof IUser
     */
    'address': string;
}
/**
 * 
 * @export
 * @interface IUserOrganisation
 */
export interface IUserOrganisation {
    /**
     * 
     * @type {boolean}
     * @memberof IUserOrganisation
     */
    'removed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IUserOrganisation
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof IUserOrganisation
     */
    'modified'?: string;
    /**
     * 
     * @type {string}
     * @memberof IUserOrganisation
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof IUserOrganisation
     */
    'user_address': string;
    /**
     * 
     * @type {string}
     * @memberof IUserOrganisation
     */
    'organisation_key': string;
    /**
     * 
     * @type {UserOrganisationType}
     * @memberof IUserOrganisation
     */
    'type': UserOrganisationType;
    /**
     * 
     * @type {boolean}
     * @memberof IUserOrganisation
     */
    'active': boolean;
}


/**
 * 
 * @export
 * @interface InitiateSession200Response
 */
export interface InitiateSession200Response {
    /**
     * 
     * @type {string}
     * @memberof InitiateSession200Response
     */
    'sessionKey': string;
    /**
     * 
     * @type {string}
     * @memberof InitiateSession200Response
     */
    'salt': string;
    /**
     * 
     * @type {string}
     * @memberof InitiateSession200Response
     */
    'userKey': string;
    /**
     * 
     * @type {string}
     * @memberof InitiateSession200Response
     */
    'encryptionKey': string;
    /**
     * 
     * @type {string}
     * @memberof InitiateSession200Response
     */
    'message': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const UserOrganisationType = {
    Admin: 'admin',
    Member: 'member'
} as const;

export type UserOrganisationType = typeof UserOrganisationType[keyof typeof UserOrganisationType];



/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ICreateAccount} iCreateAccount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (iCreateAccount: ICreateAccount, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iCreateAccount' is not null or undefined
            assertParamExists('createAccount', 'iCreateAccount', iCreateAccount)
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iCreateAccount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a filtered list of  account balances. This endpoint retrieves token balances filtered by owner address and paginated by page size and page number.
         * @param {string} address The address of the owner address to retrieve transfers for.
         * @param {number} [pageSize] The number of Transactions per page (default: 10).
         * @param {number} [pageNumber] The page number to retrieve (default: 0).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBalances: async (address: string, pageSize?: number, pageNumber?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getAccountBalances', 'address', address)
            const localVarPath = `/accounts/{address}/balances`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page_number'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a filtered list of  token transfers. This endpoint retrieves token transfers filtered by contract address and paginated by page size and page number.
         * @param {string} address The address of the owner address to retrieve transfers for.
         * @param {number} [pageSize] The number of Transactions per page (default: 10).
         * @param {number} [pageNumber] The page number to retrieve (default: 0).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTransfers: async (address: string, pageSize?: number, pageNumber?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getAccountTransfers', 'address', address)
            const localVarPath = `/accounts/{address}/transfers`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page_number'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ICreateAccount} iCreateAccount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(iCreateAccount: ICreateAccount, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(iCreateAccount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.createAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a filtered list of  account balances. This endpoint retrieves token balances filtered by owner address and paginated by page size and page number.
         * @param {string} address The address of the owner address to retrieve transfers for.
         * @param {number} [pageSize] The number of Transactions per page (default: 10).
         * @param {number} [pageNumber] The page number to retrieve (default: 0).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountBalances(address: string, pageSize?: number, pageNumber?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ITokenAccountListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountBalances(address, pageSize, pageNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.getAccountBalances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a filtered list of  token transfers. This endpoint retrieves token transfers filtered by contract address and paginated by page size and page number.
         * @param {string} address The address of the owner address to retrieve transfers for.
         * @param {number} [pageSize] The number of Transactions per page (default: 10).
         * @param {number} [pageNumber] The page number to retrieve (default: 0).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountTransfers(address: string, pageSize?: number, pageNumber?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ITokenTransferListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountTransfers(address, pageSize, pageNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.getAccountTransfers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * 
         * @param {ICreateAccount} iCreateAccount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(iCreateAccount: ICreateAccount, options?: RawAxiosRequestConfig): AxiosPromise<IAccount> {
            return localVarFp.createAccount(iCreateAccount, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a filtered list of  account balances. This endpoint retrieves token balances filtered by owner address and paginated by page size and page number.
         * @param {string} address The address of the owner address to retrieve transfers for.
         * @param {number} [pageSize] The number of Transactions per page (default: 10).
         * @param {number} [pageNumber] The page number to retrieve (default: 0).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBalances(address: string, pageSize?: number, pageNumber?: number, options?: RawAxiosRequestConfig): AxiosPromise<ITokenAccountListResponse> {
            return localVarFp.getAccountBalances(address, pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a filtered list of  token transfers. This endpoint retrieves token transfers filtered by contract address and paginated by page size and page number.
         * @param {string} address The address of the owner address to retrieve transfers for.
         * @param {number} [pageSize] The number of Transactions per page (default: 10).
         * @param {number} [pageNumber] The page number to retrieve (default: 0).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTransfers(address: string, pageSize?: number, pageNumber?: number, options?: RawAxiosRequestConfig): AxiosPromise<ITokenTransferListResponse> {
            return localVarFp.getAccountTransfers(address, pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * 
     * @param {ICreateAccount} iCreateAccount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public createAccount(iCreateAccount: ICreateAccount, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).createAccount(iCreateAccount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a filtered list of  account balances. This endpoint retrieves token balances filtered by owner address and paginated by page size and page number.
     * @param {string} address The address of the owner address to retrieve transfers for.
     * @param {number} [pageSize] The number of Transactions per page (default: 10).
     * @param {number} [pageNumber] The page number to retrieve (default: 0).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountBalances(address: string, pageSize?: number, pageNumber?: number, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccountBalances(address, pageSize, pageNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a filtered list of  token transfers. This endpoint retrieves token transfers filtered by contract address and paginated by page size and page number.
     * @param {string} address The address of the owner address to retrieve transfers for.
     * @param {number} [pageSize] The number of Transactions per page (default: 10).
     * @param {number} [pageNumber] The page number to retrieve (default: 0).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountTransfers(address: string, pageSize?: number, pageNumber?: number, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccountTransfers(address, pageSize, pageNumber, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthorisationApi - axios parameter creator
 * @export
 */
export const AuthorisationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {IPostAuthInitiate} iPostAuthInitiate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateSession: async (iPostAuthInitiate: IPostAuthInitiate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iPostAuthInitiate' is not null or undefined
            assertParamExists('initiateSession', 'iPostAuthInitiate', iPostAuthInitiate)
            const localVarPath = `/auth/session/initiate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iPostAuthInitiate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthorisationApi - functional programming interface
 * @export
 */
export const AuthorisationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthorisationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {IPostAuthInitiate} iPostAuthInitiate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiateSession(iPostAuthInitiate: IPostAuthInitiate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InitiateSession200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initiateSession(iPostAuthInitiate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorisationApi.initiateSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthorisationApi - factory interface
 * @export
 */
export const AuthorisationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthorisationApiFp(configuration)
    return {
        /**
         * 
         * @param {IPostAuthInitiate} iPostAuthInitiate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateSession(iPostAuthInitiate: IPostAuthInitiate, options?: RawAxiosRequestConfig): AxiosPromise<InitiateSession200Response> {
            return localVarFp.initiateSession(iPostAuthInitiate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthorisationApi - object-oriented interface
 * @export
 * @class AuthorisationApi
 * @extends {BaseAPI}
 */
export class AuthorisationApi extends BaseAPI {
    /**
     * 
     * @param {IPostAuthInitiate} iPostAuthInitiate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorisationApi
     */
    public initiateSession(iPostAuthInitiate: IPostAuthInitiate, options?: RawAxiosRequestConfig) {
        return AuthorisationApiFp(this.configuration).initiateSession(iPostAuthInitiate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContractExecutionsApi - axios parameter creator
 * @export
 */
export const ContractExecutionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {IPostContractExecution} iPostContractExecution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeContract: async (iPostContractExecution: IPostContractExecution, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iPostContractExecution' is not null or undefined
            assertParamExists('executeContract', 'iPostContractExecution', iPostContractExecution)
            const localVarPath = `/executions/execute`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iPostContractExecution, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutionByKey: async (key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getExecutionByKey', 'key', key)
            const localVarPath = `/executions/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} limit 
         * @param {number} offset 
         * @param {string} [contractAddress] 
         * @param {string} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutions: async (limit: number, offset: number, contractAddress?: string, status?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getExecutions', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('getExecutions', 'offset', offset)
            const localVarPath = `/executions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (contractAddress !== undefined) {
                localVarQueryParameter['contract_address'] = contractAddress;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractExecutionsApi - functional programming interface
 * @export
 */
export const ContractExecutionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContractExecutionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {IPostContractExecution} iPostContractExecution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeContract(iPostContractExecution: IPostContractExecution, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IContractExecution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeContract(iPostContractExecution, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractExecutionsApi.executeContract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExecutionByKey(key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IContractExecution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExecutionByKey(key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractExecutionsApi.getExecutionByKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} limit 
         * @param {number} offset 
         * @param {string} [contractAddress] 
         * @param {string} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExecutions(limit: number, offset: number, contractAddress?: string, status?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetExecutions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExecutions(limit, offset, contractAddress, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractExecutionsApi.getExecutions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContractExecutionsApi - factory interface
 * @export
 */
export const ContractExecutionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContractExecutionsApiFp(configuration)
    return {
        /**
         * 
         * @param {IPostContractExecution} iPostContractExecution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeContract(iPostContractExecution: IPostContractExecution, options?: RawAxiosRequestConfig): AxiosPromise<IContractExecution> {
            return localVarFp.executeContract(iPostContractExecution, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutionByKey(key: string, options?: RawAxiosRequestConfig): AxiosPromise<IContractExecution> {
            return localVarFp.getExecutionByKey(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} limit 
         * @param {number} offset 
         * @param {string} [contractAddress] 
         * @param {string} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutions(limit: number, offset: number, contractAddress?: string, status?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetExecutions200Response> {
            return localVarFp.getExecutions(limit, offset, contractAddress, status, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContractExecutionsApi - object-oriented interface
 * @export
 * @class ContractExecutionsApi
 * @extends {BaseAPI}
 */
export class ContractExecutionsApi extends BaseAPI {
    /**
     * 
     * @param {IPostContractExecution} iPostContractExecution 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractExecutionsApi
     */
    public executeContract(iPostContractExecution: IPostContractExecution, options?: RawAxiosRequestConfig) {
        return ContractExecutionsApiFp(this.configuration).executeContract(iPostContractExecution, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractExecutionsApi
     */
    public getExecutionByKey(key: string, options?: RawAxiosRequestConfig) {
        return ContractExecutionsApiFp(this.configuration).getExecutionByKey(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} limit 
     * @param {number} offset 
     * @param {string} [contractAddress] 
     * @param {string} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractExecutionsApi
     */
    public getExecutions(limit: number, offset: number, contractAddress?: string, status?: string, options?: RawAxiosRequestConfig) {
        return ContractExecutionsApiFp(this.configuration).getExecutions(limit, offset, contractAddress, status, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContractsApi - axios parameter creator
 * @export
 */
export const ContractsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a new contract. This endpoint creates a new contract with the provided contract data.
         * @param {IPostContract} iPostContract The contract data required to create the contract.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContract: async (iPostContract: IPostContract, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iPostContract' is not null or undefined
            assertParamExists('addContract', 'iPostContract', iPostContract)
            const localVarPath = `/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iPostContract, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a contract. This endpoint deploys a contract with the provided deployment data.
         * @param {IDeployContract} iDeployContract The data required to deploy the contract.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployContract: async (iDeployContract: IDeployContract, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iDeployContract' is not null or undefined
            assertParamExists('deployContract', 'iDeployContract', iDeployContract)
            const localVarPath = `/contracts/deploy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iDeployContract, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a filtered list of contracts. This endpoint retrieves contracts filtered by type and paginated by page size and page number.
         * @param {ContractType} [type] Optional filter by contract type.
         * @param {number} [pageSize] The number of contracts per page (default: 10).
         * @param {number} [pageNumber] The page number to retrieve (default: 0).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilteredContracts: async (type?: ContractType, pageSize?: number, pageNumber?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page_number'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Execute a contract by its address. This endpoint executes a contract with the provided execution data.
         * @param {string} address The address of the contract to execute.
         * @param {IPostReadContract} iPostReadContract The data required to execute the contract.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readContract: async (address: string, iPostReadContract: IPostReadContract, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('readContract', 'address', address)
            // verify required parameter 'iPostReadContract' is not null or undefined
            assertParamExists('readContract', 'iPostReadContract', iPostReadContract)
            const localVarPath = `/contracts/{address}/read`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iPostReadContract, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a webhook to a contract. This endpoint adds a webhook to a contract with the provided webhook data. The webhook will be triggered when the contract is executed.
         * @param {string} contractAddress The address of the contract to add the webhook to.
         * @param {IPostCreateWebhook} iPostCreateWebhook The data required to create the webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhook: async (contractAddress: string, iPostCreateWebhook: IPostCreateWebhook, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('webhook', 'contractAddress', contractAddress)
            // verify required parameter 'iPostCreateWebhook' is not null or undefined
            assertParamExists('webhook', 'iPostCreateWebhook', iPostCreateWebhook)
            const localVarPath = `/contracts/{contractAddress}/webhooks`
                .replace(`{${"contractAddress"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iPostCreateWebhook, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractsApi - functional programming interface
 * @export
 */
export const ContractsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContractsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a new contract. This endpoint creates a new contract with the provided contract data.
         * @param {IPostContract} iPostContract The contract data required to create the contract.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addContract(iPostContract: IPostContract, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IContract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addContract(iPostContract, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractsApi.addContract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deploy a contract. This endpoint deploys a contract with the provided deployment data.
         * @param {IDeployContract} iDeployContract The data required to deploy the contract.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployContract(iDeployContract: IDeployContract, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IContract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployContract(iDeployContract, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractsApi.deployContract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a filtered list of contracts. This endpoint retrieves contracts filtered by type and paginated by page size and page number.
         * @param {ContractType} [type] Optional filter by contract type.
         * @param {number} [pageSize] The number of contracts per page (default: 10).
         * @param {number} [pageNumber] The page number to retrieve (default: 0).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilteredContracts(type?: ContractType, pageSize?: number, pageNumber?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IContractsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFilteredContracts(type, pageSize, pageNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractsApi.getFilteredContracts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Execute a contract by its address. This endpoint executes a contract with the provided execution data.
         * @param {string} address The address of the contract to execute.
         * @param {IPostReadContract} iPostReadContract The data required to execute the contract.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readContract(address: string, iPostReadContract: IPostReadContract, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IReadContractResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readContract(address, iPostReadContract, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractsApi.readContract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a webhook to a contract. This endpoint adds a webhook to a contract with the provided webhook data. The webhook will be triggered when the contract is executed.
         * @param {string} contractAddress The address of the contract to add the webhook to.
         * @param {IPostCreateWebhook} iPostCreateWebhook The data required to create the webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhook(contractAddress: string, iPostCreateWebhook: IPostCreateWebhook, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhook(contractAddress, iPostCreateWebhook, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractsApi.webhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContractsApi - factory interface
 * @export
 */
export const ContractsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContractsApiFp(configuration)
    return {
        /**
         * Add a new contract. This endpoint creates a new contract with the provided contract data.
         * @param {IPostContract} iPostContract The contract data required to create the contract.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContract(iPostContract: IPostContract, options?: RawAxiosRequestConfig): AxiosPromise<IContract> {
            return localVarFp.addContract(iPostContract, options).then((request) => request(axios, basePath));
        },
        /**
         * Deploy a contract. This endpoint deploys a contract with the provided deployment data.
         * @param {IDeployContract} iDeployContract The data required to deploy the contract.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployContract(iDeployContract: IDeployContract, options?: RawAxiosRequestConfig): AxiosPromise<IContract> {
            return localVarFp.deployContract(iDeployContract, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a filtered list of contracts. This endpoint retrieves contracts filtered by type and paginated by page size and page number.
         * @param {ContractType} [type] Optional filter by contract type.
         * @param {number} [pageSize] The number of contracts per page (default: 10).
         * @param {number} [pageNumber] The page number to retrieve (default: 0).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilteredContracts(type?: ContractType, pageSize?: number, pageNumber?: number, options?: RawAxiosRequestConfig): AxiosPromise<IContractsListResponse> {
            return localVarFp.getFilteredContracts(type, pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Execute a contract by its address. This endpoint executes a contract with the provided execution data.
         * @param {string} address The address of the contract to execute.
         * @param {IPostReadContract} iPostReadContract The data required to execute the contract.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readContract(address: string, iPostReadContract: IPostReadContract, options?: RawAxiosRequestConfig): AxiosPromise<IReadContractResponse> {
            return localVarFp.readContract(address, iPostReadContract, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a webhook to a contract. This endpoint adds a webhook to a contract with the provided webhook data. The webhook will be triggered when the contract is executed.
         * @param {string} contractAddress The address of the contract to add the webhook to.
         * @param {IPostCreateWebhook} iPostCreateWebhook The data required to create the webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhook(contractAddress: string, iPostCreateWebhook: IPostCreateWebhook, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.webhook(contractAddress, iPostCreateWebhook, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContractsApi - object-oriented interface
 * @export
 * @class ContractsApi
 * @extends {BaseAPI}
 */
export class ContractsApi extends BaseAPI {
    /**
     * Add a new contract. This endpoint creates a new contract with the provided contract data.
     * @param {IPostContract} iPostContract The contract data required to create the contract.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public addContract(iPostContract: IPostContract, options?: RawAxiosRequestConfig) {
        return ContractsApiFp(this.configuration).addContract(iPostContract, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deploy a contract. This endpoint deploys a contract with the provided deployment data.
     * @param {IDeployContract} iDeployContract The data required to deploy the contract.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public deployContract(iDeployContract: IDeployContract, options?: RawAxiosRequestConfig) {
        return ContractsApiFp(this.configuration).deployContract(iDeployContract, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a filtered list of contracts. This endpoint retrieves contracts filtered by type and paginated by page size and page number.
     * @param {ContractType} [type] Optional filter by contract type.
     * @param {number} [pageSize] The number of contracts per page (default: 10).
     * @param {number} [pageNumber] The page number to retrieve (default: 0).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public getFilteredContracts(type?: ContractType, pageSize?: number, pageNumber?: number, options?: RawAxiosRequestConfig) {
        return ContractsApiFp(this.configuration).getFilteredContracts(type, pageSize, pageNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Execute a contract by its address. This endpoint executes a contract with the provided execution data.
     * @param {string} address The address of the contract to execute.
     * @param {IPostReadContract} iPostReadContract The data required to execute the contract.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public readContract(address: string, iPostReadContract: IPostReadContract, options?: RawAxiosRequestConfig) {
        return ContractsApiFp(this.configuration).readContract(address, iPostReadContract, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a webhook to a contract. This endpoint adds a webhook to a contract with the provided webhook data. The webhook will be triggered when the contract is executed.
     * @param {string} contractAddress The address of the contract to add the webhook to.
     * @param {IPostCreateWebhook} iPostCreateWebhook The data required to create the webhook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public webhook(contractAddress: string, iPostCreateWebhook: IPostCreateWebhook, options?: RawAxiosRequestConfig) {
        return ContractsApiFp(this.configuration).webhook(contractAddress, iPostCreateWebhook, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSiteStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSiteStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSiteStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSiteStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSiteStatus(options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.getSiteStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSiteStatus(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSiteStatus(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganisationsApi - axios parameter creator
 * @export
 */
export const OrganisationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new organisation. This endpoint will create a new organisation with the given data and return the created organisation, including its API key.
         * @param {IPostOrganisation} iPostOrganisation The data required to create a new organisation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganisation: async (iPostOrganisation: IPostOrganisation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iPostOrganisation' is not null or undefined
            assertParamExists('createOrganisation', 'iPostOrganisation', iPostOrganisation)
            const localVarPath = `/organisations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iPostOrganisation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an organisation by its ID.  This endpoint returns an organisation with the given ID.
         * @param {string} id The ID of the organisation to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisationById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrganisationById', 'id', id)
            const localVarPath = `/organisations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of organisations with optional filters. This endpoint retrieves a list of organisations, optionally filtered by name.
         * @param {string} [name] Optional name filter to search for organisations by name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisations: async (name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organisations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing organisation by its ID. This endpoint updates an organisation with the provided data.
         * @param {string} id The ID of the organisation to update.
         * @param {IPostOrganisation} iPostOrganisation The updated organisation data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganisationById: async (id: string, iPostOrganisation: IPostOrganisation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateOrganisationById', 'id', id)
            // verify required parameter 'iPostOrganisation' is not null or undefined
            assertParamExists('updateOrganisationById', 'iPostOrganisation', iPostOrganisation)
            const localVarPath = `/organisations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iPostOrganisation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganisationsApi - functional programming interface
 * @export
 */
export const OrganisationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganisationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new organisation. This endpoint will create a new organisation with the given data and return the created organisation, including its API key.
         * @param {IPostOrganisation} iPostOrganisation The data required to create a new organisation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganisation(iPostOrganisation: IPostOrganisation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IPostOrganisationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganisation(iPostOrganisation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationsApi.createOrganisation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an organisation by its ID.  This endpoint returns an organisation with the given ID.
         * @param {string} id The ID of the organisation to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganisationById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IOrganisation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganisationById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationsApi.getOrganisationById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of organisations with optional filters. This endpoint retrieves a list of organisations, optionally filtered by name.
         * @param {string} [name] Optional name filter to search for organisations by name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganisations(name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IOrganisation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganisations(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationsApi.getOrganisations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing organisation by its ID. This endpoint updates an organisation with the provided data.
         * @param {string} id The ID of the organisation to update.
         * @param {IPostOrganisation} iPostOrganisation The updated organisation data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganisationById(id: string, iPostOrganisation: IPostOrganisation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IOrganisation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganisationById(id, iPostOrganisation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationsApi.updateOrganisationById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganisationsApi - factory interface
 * @export
 */
export const OrganisationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganisationsApiFp(configuration)
    return {
        /**
         * Create a new organisation. This endpoint will create a new organisation with the given data and return the created organisation, including its API key.
         * @param {IPostOrganisation} iPostOrganisation The data required to create a new organisation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganisation(iPostOrganisation: IPostOrganisation, options?: RawAxiosRequestConfig): AxiosPromise<IPostOrganisationResponse> {
            return localVarFp.createOrganisation(iPostOrganisation, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an organisation by its ID.  This endpoint returns an organisation with the given ID.
         * @param {string} id The ID of the organisation to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisationById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<IOrganisation> {
            return localVarFp.getOrganisationById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of organisations with optional filters. This endpoint retrieves a list of organisations, optionally filtered by name.
         * @param {string} [name] Optional name filter to search for organisations by name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisations(name?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<IOrganisation>> {
            return localVarFp.getOrganisations(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing organisation by its ID. This endpoint updates an organisation with the provided data.
         * @param {string} id The ID of the organisation to update.
         * @param {IPostOrganisation} iPostOrganisation The updated organisation data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganisationById(id: string, iPostOrganisation: IPostOrganisation, options?: RawAxiosRequestConfig): AxiosPromise<IOrganisation> {
            return localVarFp.updateOrganisationById(id, iPostOrganisation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganisationsApi - object-oriented interface
 * @export
 * @class OrganisationsApi
 * @extends {BaseAPI}
 */
export class OrganisationsApi extends BaseAPI {
    /**
     * Create a new organisation. This endpoint will create a new organisation with the given data and return the created organisation, including its API key.
     * @param {IPostOrganisation} iPostOrganisation The data required to create a new organisation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationsApi
     */
    public createOrganisation(iPostOrganisation: IPostOrganisation, options?: RawAxiosRequestConfig) {
        return OrganisationsApiFp(this.configuration).createOrganisation(iPostOrganisation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an organisation by its ID.  This endpoint returns an organisation with the given ID.
     * @param {string} id The ID of the organisation to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationsApi
     */
    public getOrganisationById(id: string, options?: RawAxiosRequestConfig) {
        return OrganisationsApiFp(this.configuration).getOrganisationById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of organisations with optional filters. This endpoint retrieves a list of organisations, optionally filtered by name.
     * @param {string} [name] Optional name filter to search for organisations by name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationsApi
     */
    public getOrganisations(name?: string, options?: RawAxiosRequestConfig) {
        return OrganisationsApiFp(this.configuration).getOrganisations(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing organisation by its ID. This endpoint updates an organisation with the provided data.
     * @param {string} id The ID of the organisation to update.
     * @param {IPostOrganisation} iPostOrganisation The updated organisation data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationsApi
     */
    public updateOrganisationById(id: string, iPostOrganisation: IPostOrganisation, options?: RawAxiosRequestConfig) {
        return OrganisationsApiFp(this.configuration).updateOrganisationById(id, iPostOrganisation, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TokensApi - axios parameter creator
 * @export
 */
export const TokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Transfers a specified ERC1155 token from one address to another.
         * @param {string} contractAddress The address of the ERC1155 token contract
         * @param {IPostTransferErc1155} iPostTransferErc1155 The transfer parameters containing: - from: The address sending the token - to: The address receiving the token - tokenId: The ID of the token to transfer - amount: The amount of tokens to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createErc1155Transfer: async (contractAddress: string, iPostTransferErc1155: IPostTransferErc1155, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('createErc1155Transfer', 'contractAddress', contractAddress)
            // verify required parameter 'iPostTransferErc1155' is not null or undefined
            assertParamExists('createErc1155Transfer', 'iPostTransferErc1155', iPostTransferErc1155)
            const localVarPath = `/tokens/transfer/erc1155/{contractAddress}`
                .replace(`{${"contractAddress"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iPostTransferErc1155, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transfers a specified amount of ERC20 tokens from one address to another.
         * @param {string} contractAddress The address of the ERC20 token contract
         * @param {IPostTransferErc20} iPostTransferErc20 The transfer parameters containing: - from: The address sending the tokens - to: The address receiving the tokens - amount: The amount of tokens to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createErc20transfer: async (contractAddress: string, iPostTransferErc20: IPostTransferErc20, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('createErc20transfer', 'contractAddress', contractAddress)
            // verify required parameter 'iPostTransferErc20' is not null or undefined
            assertParamExists('createErc20transfer', 'iPostTransferErc20', iPostTransferErc20)
            const localVarPath = `/tokens/transfer/erc20/{contractAddress}`
                .replace(`{${"contractAddress"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iPostTransferErc20, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transfers a specified ERC721 token from one address to another.
         * @param {string} contractAddress The address of the ERC721 token contract
         * @param {IPostTransferErc721} iPostTransferErc721 The transfer parameters containing: - from: The address sending the token - to: The address receiving the token - tokenId: The ID of the token to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createErc721Transfer: async (contractAddress: string, iPostTransferErc721: IPostTransferErc721, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('createErc721Transfer', 'contractAddress', contractAddress)
            // verify required parameter 'iPostTransferErc721' is not null or undefined
            assertParamExists('createErc721Transfer', 'iPostTransferErc721', iPostTransferErc721)
            const localVarPath = `/tokens/transfer/erc721/{contractAddress}`
                .replace(`{${"contractAddress"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iPostTransferErc721, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contractAddress 
         * @param {number} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNFTMetadata: async (contractAddress: string, tokenId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('getNFTMetadata', 'contractAddress', contractAddress)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('getNFTMetadata', 'tokenId', tokenId)
            const localVarPath = `/tokens/metadata/{contractAddress}/{tokenId}`
                .replace(`{${"contractAddress"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a filtered list of  token balances. This endpoint retrieves token balances filtered by contract address and paginated by page size and page number.
         * @param {string} address The address of the token to retrieve transfers for.
         * @param {number} [pageSize] The number of Transactions per page (default: 10).
         * @param {number} [pageNumber] The page number to retrieve (default: 0).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenBalances: async (address: string, pageSize?: number, pageNumber?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getTokenBalances', 'address', address)
            const localVarPath = `/tokens/{address}/balances`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page_number'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a filtered list of  token transfers. This endpoint retrieves token transfers filtered by contract address and paginated by page size and page number.
         * @param {string} address The address of the token to retrieve transfers for.
         * @param {number} [pageSize] The number of Transactions per page (default: 10).
         * @param {number} [pageNumber] The page number to retrieve (default: 0).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenTransfers: async (address: string, pageSize?: number, pageNumber?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getTokenTransfers', 'address', address)
            const localVarPath = `/tokens/{address}/transfers`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page_number'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contractAddress 
         * @param {IPostMintErc155} iPostMintErc155 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintERC1155Token: async (contractAddress: string, iPostMintErc155: IPostMintErc155, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('mintERC1155Token', 'contractAddress', contractAddress)
            // verify required parameter 'iPostMintErc155' is not null or undefined
            assertParamExists('mintERC1155Token', 'iPostMintErc155', iPostMintErc155)
            const localVarPath = `/tokens/mint/erc1155/{contractAddress}`
                .replace(`{${"contractAddress"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iPostMintErc155, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contractAddress 
         * @param {IPostMintErc20} iPostMintErc20 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintERC20Token: async (contractAddress: string, iPostMintErc20: IPostMintErc20, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('mintERC20Token', 'contractAddress', contractAddress)
            // verify required parameter 'iPostMintErc20' is not null or undefined
            assertParamExists('mintERC20Token', 'iPostMintErc20', iPostMintErc20)
            const localVarPath = `/tokens/mint/erc20/{contractAddress}`
                .replace(`{${"contractAddress"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iPostMintErc20, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contractAddress 
         * @param {IPostMintErc721} iPostMintErc721 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintERC721Token: async (contractAddress: string, iPostMintErc721: IPostMintErc721, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('mintERC721Token', 'contractAddress', contractAddress)
            // verify required parameter 'iPostMintErc721' is not null or undefined
            assertParamExists('mintERC721Token', 'iPostMintErc721', iPostMintErc721)
            const localVarPath = `/tokens/mint/erc721/{contractAddress}`
                .replace(`{${"contractAddress"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iPostMintErc721, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contractAddress 
         * @param {number} tokenId 
         * @param {INFTMetadata} iNFTMetadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNFTMetadata: async (contractAddress: string, tokenId: number, iNFTMetadata: INFTMetadata, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('postNFTMetadata', 'contractAddress', contractAddress)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('postNFTMetadata', 'tokenId', tokenId)
            // verify required parameter 'iNFTMetadata' is not null or undefined
            assertParamExists('postNFTMetadata', 'iNFTMetadata', iNFTMetadata)
            const localVarPath = `/tokens/metadata/{contractAddress}/{tokenId}`
                .replace(`{${"contractAddress"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iNFTMetadata, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contractAddress 
         * @param {number} tokenId 
         * @param {INFTMetadata} iNFTMetadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putNFTMetadata: async (contractAddress: string, tokenId: number, iNFTMetadata: INFTMetadata, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('putNFTMetadata', 'contractAddress', contractAddress)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('putNFTMetadata', 'tokenId', tokenId)
            // verify required parameter 'iNFTMetadata' is not null or undefined
            assertParamExists('putNFTMetadata', 'iNFTMetadata', iNFTMetadata)
            const localVarPath = `/tokens/metadata/{contractAddress}/{tokenId}`
                .replace(`{${"contractAddress"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iNFTMetadata, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokensApi - functional programming interface
 * @export
 */
export const TokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokensApiAxiosParamCreator(configuration)
    return {
        /**
         * Transfers a specified ERC1155 token from one address to another.
         * @param {string} contractAddress The address of the ERC1155 token contract
         * @param {IPostTransferErc1155} iPostTransferErc1155 The transfer parameters containing: - from: The address sending the token - to: The address receiving the token - tokenId: The ID of the token to transfer - amount: The amount of tokens to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createErc1155Transfer(contractAddress: string, iPostTransferErc1155: IPostTransferErc1155, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IContractExecution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createErc1155Transfer(contractAddress, iPostTransferErc1155, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TokensApi.createErc1155Transfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Transfers a specified amount of ERC20 tokens from one address to another.
         * @param {string} contractAddress The address of the ERC20 token contract
         * @param {IPostTransferErc20} iPostTransferErc20 The transfer parameters containing: - from: The address sending the tokens - to: The address receiving the tokens - amount: The amount of tokens to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createErc20transfer(contractAddress: string, iPostTransferErc20: IPostTransferErc20, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IContractExecution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createErc20transfer(contractAddress, iPostTransferErc20, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TokensApi.createErc20transfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Transfers a specified ERC721 token from one address to another.
         * @param {string} contractAddress The address of the ERC721 token contract
         * @param {IPostTransferErc721} iPostTransferErc721 The transfer parameters containing: - from: The address sending the token - to: The address receiving the token - tokenId: The ID of the token to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createErc721Transfer(contractAddress: string, iPostTransferErc721: IPostTransferErc721, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IContractExecution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createErc721Transfer(contractAddress, iPostTransferErc721, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TokensApi.createErc721Transfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} contractAddress 
         * @param {number} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNFTMetadata(contractAddress: string, tokenId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<INFTMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNFTMetadata(contractAddress, tokenId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TokensApi.getNFTMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a filtered list of  token balances. This endpoint retrieves token balances filtered by contract address and paginated by page size and page number.
         * @param {string} address The address of the token to retrieve transfers for.
         * @param {number} [pageSize] The number of Transactions per page (default: 10).
         * @param {number} [pageNumber] The page number to retrieve (default: 0).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokenBalances(address: string, pageSize?: number, pageNumber?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ITokenAccountListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokenBalances(address, pageSize, pageNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TokensApi.getTokenBalances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a filtered list of  token transfers. This endpoint retrieves token transfers filtered by contract address and paginated by page size and page number.
         * @param {string} address The address of the token to retrieve transfers for.
         * @param {number} [pageSize] The number of Transactions per page (default: 10).
         * @param {number} [pageNumber] The page number to retrieve (default: 0).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokenTransfers(address: string, pageSize?: number, pageNumber?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ITokenTransferListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokenTransfers(address, pageSize, pageNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TokensApi.getTokenTransfers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} contractAddress 
         * @param {IPostMintErc155} iPostMintErc155 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mintERC1155Token(contractAddress: string, iPostMintErc155: IPostMintErc155, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IContractExecution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mintERC1155Token(contractAddress, iPostMintErc155, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TokensApi.mintERC1155Token']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} contractAddress 
         * @param {IPostMintErc20} iPostMintErc20 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mintERC20Token(contractAddress: string, iPostMintErc20: IPostMintErc20, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IContractExecution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mintERC20Token(contractAddress, iPostMintErc20, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TokensApi.mintERC20Token']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} contractAddress 
         * @param {IPostMintErc721} iPostMintErc721 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mintERC721Token(contractAddress: string, iPostMintErc721: IPostMintErc721, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IContractExecution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mintERC721Token(contractAddress, iPostMintErc721, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TokensApi.mintERC721Token']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} contractAddress 
         * @param {number} tokenId 
         * @param {INFTMetadata} iNFTMetadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postNFTMetadata(contractAddress: string, tokenId: number, iNFTMetadata: INFTMetadata, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<INFTMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postNFTMetadata(contractAddress, tokenId, iNFTMetadata, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TokensApi.postNFTMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} contractAddress 
         * @param {number} tokenId 
         * @param {INFTMetadata} iNFTMetadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putNFTMetadata(contractAddress: string, tokenId: number, iNFTMetadata: INFTMetadata, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<INFTMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putNFTMetadata(contractAddress, tokenId, iNFTMetadata, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TokensApi.putNFTMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TokensApi - factory interface
 * @export
 */
export const TokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokensApiFp(configuration)
    return {
        /**
         * Transfers a specified ERC1155 token from one address to another.
         * @param {string} contractAddress The address of the ERC1155 token contract
         * @param {IPostTransferErc1155} iPostTransferErc1155 The transfer parameters containing: - from: The address sending the token - to: The address receiving the token - tokenId: The ID of the token to transfer - amount: The amount of tokens to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createErc1155Transfer(contractAddress: string, iPostTransferErc1155: IPostTransferErc1155, options?: RawAxiosRequestConfig): AxiosPromise<IContractExecution> {
            return localVarFp.createErc1155Transfer(contractAddress, iPostTransferErc1155, options).then((request) => request(axios, basePath));
        },
        /**
         * Transfers a specified amount of ERC20 tokens from one address to another.
         * @param {string} contractAddress The address of the ERC20 token contract
         * @param {IPostTransferErc20} iPostTransferErc20 The transfer parameters containing: - from: The address sending the tokens - to: The address receiving the tokens - amount: The amount of tokens to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createErc20transfer(contractAddress: string, iPostTransferErc20: IPostTransferErc20, options?: RawAxiosRequestConfig): AxiosPromise<IContractExecution> {
            return localVarFp.createErc20transfer(contractAddress, iPostTransferErc20, options).then((request) => request(axios, basePath));
        },
        /**
         * Transfers a specified ERC721 token from one address to another.
         * @param {string} contractAddress The address of the ERC721 token contract
         * @param {IPostTransferErc721} iPostTransferErc721 The transfer parameters containing: - from: The address sending the token - to: The address receiving the token - tokenId: The ID of the token to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createErc721Transfer(contractAddress: string, iPostTransferErc721: IPostTransferErc721, options?: RawAxiosRequestConfig): AxiosPromise<IContractExecution> {
            return localVarFp.createErc721Transfer(contractAddress, iPostTransferErc721, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} contractAddress 
         * @param {number} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNFTMetadata(contractAddress: string, tokenId: number, options?: RawAxiosRequestConfig): AxiosPromise<INFTMetadata> {
            return localVarFp.getNFTMetadata(contractAddress, tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a filtered list of  token balances. This endpoint retrieves token balances filtered by contract address and paginated by page size and page number.
         * @param {string} address The address of the token to retrieve transfers for.
         * @param {number} [pageSize] The number of Transactions per page (default: 10).
         * @param {number} [pageNumber] The page number to retrieve (default: 0).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenBalances(address: string, pageSize?: number, pageNumber?: number, options?: RawAxiosRequestConfig): AxiosPromise<ITokenAccountListResponse> {
            return localVarFp.getTokenBalances(address, pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a filtered list of  token transfers. This endpoint retrieves token transfers filtered by contract address and paginated by page size and page number.
         * @param {string} address The address of the token to retrieve transfers for.
         * @param {number} [pageSize] The number of Transactions per page (default: 10).
         * @param {number} [pageNumber] The page number to retrieve (default: 0).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenTransfers(address: string, pageSize?: number, pageNumber?: number, options?: RawAxiosRequestConfig): AxiosPromise<ITokenTransferListResponse> {
            return localVarFp.getTokenTransfers(address, pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} contractAddress 
         * @param {IPostMintErc155} iPostMintErc155 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintERC1155Token(contractAddress: string, iPostMintErc155: IPostMintErc155, options?: RawAxiosRequestConfig): AxiosPromise<IContractExecution> {
            return localVarFp.mintERC1155Token(contractAddress, iPostMintErc155, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} contractAddress 
         * @param {IPostMintErc20} iPostMintErc20 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintERC20Token(contractAddress: string, iPostMintErc20: IPostMintErc20, options?: RawAxiosRequestConfig): AxiosPromise<IContractExecution> {
            return localVarFp.mintERC20Token(contractAddress, iPostMintErc20, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} contractAddress 
         * @param {IPostMintErc721} iPostMintErc721 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintERC721Token(contractAddress: string, iPostMintErc721: IPostMintErc721, options?: RawAxiosRequestConfig): AxiosPromise<IContractExecution> {
            return localVarFp.mintERC721Token(contractAddress, iPostMintErc721, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} contractAddress 
         * @param {number} tokenId 
         * @param {INFTMetadata} iNFTMetadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNFTMetadata(contractAddress: string, tokenId: number, iNFTMetadata: INFTMetadata, options?: RawAxiosRequestConfig): AxiosPromise<INFTMetadata> {
            return localVarFp.postNFTMetadata(contractAddress, tokenId, iNFTMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} contractAddress 
         * @param {number} tokenId 
         * @param {INFTMetadata} iNFTMetadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putNFTMetadata(contractAddress: string, tokenId: number, iNFTMetadata: INFTMetadata, options?: RawAxiosRequestConfig): AxiosPromise<INFTMetadata> {
            return localVarFp.putNFTMetadata(contractAddress, tokenId, iNFTMetadata, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokensApi - object-oriented interface
 * @export
 * @class TokensApi
 * @extends {BaseAPI}
 */
export class TokensApi extends BaseAPI {
    /**
     * Transfers a specified ERC1155 token from one address to another.
     * @param {string} contractAddress The address of the ERC1155 token contract
     * @param {IPostTransferErc1155} iPostTransferErc1155 The transfer parameters containing: - from: The address sending the token - to: The address receiving the token - tokenId: The ID of the token to transfer - amount: The amount of tokens to transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public createErc1155Transfer(contractAddress: string, iPostTransferErc1155: IPostTransferErc1155, options?: RawAxiosRequestConfig) {
        return TokensApiFp(this.configuration).createErc1155Transfer(contractAddress, iPostTransferErc1155, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Transfers a specified amount of ERC20 tokens from one address to another.
     * @param {string} contractAddress The address of the ERC20 token contract
     * @param {IPostTransferErc20} iPostTransferErc20 The transfer parameters containing: - from: The address sending the tokens - to: The address receiving the tokens - amount: The amount of tokens to transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public createErc20transfer(contractAddress: string, iPostTransferErc20: IPostTransferErc20, options?: RawAxiosRequestConfig) {
        return TokensApiFp(this.configuration).createErc20transfer(contractAddress, iPostTransferErc20, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Transfers a specified ERC721 token from one address to another.
     * @param {string} contractAddress The address of the ERC721 token contract
     * @param {IPostTransferErc721} iPostTransferErc721 The transfer parameters containing: - from: The address sending the token - to: The address receiving the token - tokenId: The ID of the token to transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public createErc721Transfer(contractAddress: string, iPostTransferErc721: IPostTransferErc721, options?: RawAxiosRequestConfig) {
        return TokensApiFp(this.configuration).createErc721Transfer(contractAddress, iPostTransferErc721, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} contractAddress 
     * @param {number} tokenId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public getNFTMetadata(contractAddress: string, tokenId: number, options?: RawAxiosRequestConfig) {
        return TokensApiFp(this.configuration).getNFTMetadata(contractAddress, tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a filtered list of  token balances. This endpoint retrieves token balances filtered by contract address and paginated by page size and page number.
     * @param {string} address The address of the token to retrieve transfers for.
     * @param {number} [pageSize] The number of Transactions per page (default: 10).
     * @param {number} [pageNumber] The page number to retrieve (default: 0).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public getTokenBalances(address: string, pageSize?: number, pageNumber?: number, options?: RawAxiosRequestConfig) {
        return TokensApiFp(this.configuration).getTokenBalances(address, pageSize, pageNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a filtered list of  token transfers. This endpoint retrieves token transfers filtered by contract address and paginated by page size and page number.
     * @param {string} address The address of the token to retrieve transfers for.
     * @param {number} [pageSize] The number of Transactions per page (default: 10).
     * @param {number} [pageNumber] The page number to retrieve (default: 0).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public getTokenTransfers(address: string, pageSize?: number, pageNumber?: number, options?: RawAxiosRequestConfig) {
        return TokensApiFp(this.configuration).getTokenTransfers(address, pageSize, pageNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} contractAddress 
     * @param {IPostMintErc155} iPostMintErc155 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public mintERC1155Token(contractAddress: string, iPostMintErc155: IPostMintErc155, options?: RawAxiosRequestConfig) {
        return TokensApiFp(this.configuration).mintERC1155Token(contractAddress, iPostMintErc155, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} contractAddress 
     * @param {IPostMintErc20} iPostMintErc20 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public mintERC20Token(contractAddress: string, iPostMintErc20: IPostMintErc20, options?: RawAxiosRequestConfig) {
        return TokensApiFp(this.configuration).mintERC20Token(contractAddress, iPostMintErc20, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} contractAddress 
     * @param {IPostMintErc721} iPostMintErc721 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public mintERC721Token(contractAddress: string, iPostMintErc721: IPostMintErc721, options?: RawAxiosRequestConfig) {
        return TokensApiFp(this.configuration).mintERC721Token(contractAddress, iPostMintErc721, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} contractAddress 
     * @param {number} tokenId 
     * @param {INFTMetadata} iNFTMetadata 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public postNFTMetadata(contractAddress: string, tokenId: number, iNFTMetadata: INFTMetadata, options?: RawAxiosRequestConfig) {
        return TokensApiFp(this.configuration).postNFTMetadata(contractAddress, tokenId, iNFTMetadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} contractAddress 
     * @param {number} tokenId 
     * @param {INFTMetadata} iNFTMetadata 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public putNFTMetadata(contractAddress: string, tokenId: number, iNFTMetadata: INFTMetadata, options?: RawAxiosRequestConfig) {
        return TokensApiFp(this.configuration).putNFTMetadata(contractAddress, tokenId, iNFTMetadata, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a transaction by its hash.    This endpoint retrieves a transaction by its hash.
         * @param {string} hash The hash of the transaction to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByHash: async (hash: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('getTransactionByHash', 'hash', hash)
            const localVarPath = `/transactions/{hash}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a filtered list of Transactions. This endpoint retrieves Transactions filtered and paginated by page size and page number.
         * @param {number} [pageSize] The number of Transactions per page (default: 10).
         * @param {number} [pageNumber] The page number to retrieve (default: 0).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions: async (pageSize?: number, pageNumber?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page_number'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a transaction by its hash.    This endpoint retrieves a transaction by its hash.
         * @param {string} hash The hash of the transaction to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionByHash(hash: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ITransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionByHash(hash, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.getTransactionByHash']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a filtered list of Transactions. This endpoint retrieves Transactions filtered and paginated by page size and page number.
         * @param {number} [pageSize] The number of Transactions per page (default: 10).
         * @param {number} [pageNumber] The page number to retrieve (default: 0).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactions(pageSize?: number, pageNumber?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ITransactionListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactions(pageSize, pageNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.getTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * Get a transaction by its hash.    This endpoint retrieves a transaction by its hash.
         * @param {string} hash The hash of the transaction to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByHash(hash: string, options?: RawAxiosRequestConfig): AxiosPromise<ITransaction> {
            return localVarFp.getTransactionByHash(hash, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a filtered list of Transactions. This endpoint retrieves Transactions filtered and paginated by page size and page number.
         * @param {number} [pageSize] The number of Transactions per page (default: 10).
         * @param {number} [pageNumber] The page number to retrieve (default: 0).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions(pageSize?: number, pageNumber?: number, options?: RawAxiosRequestConfig): AxiosPromise<ITransactionListResponse> {
            return localVarFp.getTransactions(pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * Get a transaction by its hash.    This endpoint retrieves a transaction by its hash.
     * @param {string} hash The hash of the transaction to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionByHash(hash: string, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getTransactionByHash(hash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a filtered list of Transactions. This endpoint retrieves Transactions filtered and paginated by page size and page number.
     * @param {number} [pageSize] The number of Transactions per page (default: 10).
     * @param {number} [pageNumber] The page number to retrieve (default: 0).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactions(pageSize?: number, pageNumber?: number, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getTransactions(pageSize, pageNumber, options).then((request) => request(this.axios, this.basePath));
    }
}



